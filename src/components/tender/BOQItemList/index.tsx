import React, { useState, useCallback, useMemo } from 'react';\nimport {\n  Input,\n  Modal,\n  message\n} from 'antd';\nimport { boqApi } from '../../../lib/supabase/api';\nimport type { \n  BOQItemWithLibrary, \n  BOQItemUpdate\n} from '../../../lib/supabase/types';\nimport type { BOQItemListProps, EditingItem } from './types';\nimport DraggableList from './DraggableList';\nimport VirtualList from './VirtualList';\n\nconst BOQItemList: React.FC<BOQItemListProps> = ({\n  items,\n  clientPositionId,\n  onUpdate,\n  maxHeight = 600,\n  searchable = true,\n  editable = true\n}) => {\n  console.log('ðŸš€ BOQItemList called with:', {\n    itemsCount: items.length,\n    clientPositionId,\n    maxHeight,\n    searchable,\n    editable\n  });\n\n  const [searchTerm, setSearchTerm] = useState('');\n  const [editingItem, setEditingItem] = useState<EditingItem | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [localItems, setLocalItems] = useState(items);\n\n  // Update local items when props change\n  React.useEffect(() => {\n    console.log('ðŸ”„ Items prop changed, updating local items');\n    setLocalItems(items);\n  }, [items]);\n\n  // Filter items based on search term\n  const filteredItems = useMemo(() => {\n    if (!searchTerm.trim()) {\n      return localItems;\n    }\n    \n    const filtered = localItems.filter(item => \n      item.description.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      item.item_number.toLowerCase().includes(searchTerm.toLowerCase()) ||\n      (item.notes && item.notes.toLowerCase().includes(searchTerm.toLowerCase()))\n    );\n    \n    console.log('ðŸ” Filtered items:', { searchTerm, originalCount: localItems.length, filteredCount: filtered.length });\n    return filtered;\n  }, [localItems, searchTerm]);\n\n  const handleSearchChange = useCallback((value: string) => {\n    console.log('ðŸ” Search term changed:', value);\n    setSearchTerm(value);\n  }, []);\n\n  const handleReorder = useCallback((newOrder: BOQItemWithLibrary[]) => {\n    console.log('ðŸ”„ Reordering items locally');\n    setLocalItems(newOrder);\n  }, []);\n\n  const handleStartEdit = useCallback((itemId: string, field: 'description' | 'quantity' | 'unit_rate', currentValue: string | number) => {\n    console.log('âœï¸ Starting edit:', { itemId, field, currentValue });\n    setEditingItem({ id: itemId, field, value: currentValue });\n  }, []);\n\n  const handleSaveEdit = useCallback(async () => {\n    if (!editingItem) {\n      console.warn('âš ï¸ No editing item to save');\n      return;\n    }\n\n    console.log('ðŸ’¾ Saving edit:', editingItem);\n    setIsLoading(true);\n\n    try {\n      const updates: BOQItemUpdate = {\n        [editingItem.field]: editingItem.value\n      };\n\n      console.log('ðŸ“¡ Calling BOQ update API:', { id: editingItem.id, updates });\n      const result = await boqApi.update(editingItem.id, updates);\n      console.log('ðŸ“¦ Update API response:', result);\n\n      if (result.error) {\n        console.error('âŒ Update failed:', result.error);\n        message.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°');\n        return;\n      }\n\n      console.log('âœ… Update successful');\n      message.success('Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½');\n      setEditingItem(null);\n      onUpdate();\n    } catch (error) {\n      console.error('ðŸ’¥ Exception during update:', error);\n      message.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [editingItem, onUpdate]);\n\n  const handleCancelEdit = useCallback(() => {\n    console.log('âŒ Canceling edit:', editingItem?.id);\n    setEditingItem(null);\n  }, [editingItem]);\n\n  const handleDelete = useCallback(async (itemId: string) => {\n    console.log('ðŸ—‘ï¸ Delete requested for item:', itemId);\n    \n    const item = localItems.find(i => i.id === itemId);\n    if (!item) {\n      console.error('âŒ Item not found for deletion:', itemId);\n      return;\n    }\n\n    Modal.confirm({\n      title: 'ÐŸÐ¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ðµ ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ',\n      content: `Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹, Ñ‡Ñ‚Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚ \"${item.description}\"?`,\n      okText: 'Ð£Ð´Ð°Ð»Ð¸Ñ‚ÑŒ',\n      cancelText: 'ÐžÑ‚Ð¼ÐµÐ½Ð°',\n      okButtonProps: { danger: true },\n      onOk: async () => {\n        console.log('âœ… Delete confirmed for item:', itemId);\n        setIsLoading(true);\n\n        try {\n          console.log('ðŸ“¡ Calling BOQ delete API:', itemId);\n          const result = await boqApi.delete(itemId);\n          console.log('ðŸ“¦ Delete API response:', result);\n\n          if (result.error) {\n            console.error('âŒ Delete failed:', result.error);\n            message.error('ÐžÑˆÐ¸Ð±ÐºÐ° ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°');\n            return;\n          }\n\n          console.log('âœ… Delete successful');\n          message.success('Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚ ÑƒÐ´Ð°Ð»ÐµÐ½');\n          onUpdate();\n        } catch (error) {\n          console.error('ðŸ’¥ Exception during delete:', error);\n          message.error('ÐžÑˆÐ¸Ð±ÐºÐ° ÑƒÐ´Ð°Ð»ÐµÐ½Ð¸Ñ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°');\n        } finally {\n          setIsLoading(false);\n        }\n      }\n    });\n  }, [localItems, onUpdate]);\n\n  const handleDuplicate = useCallback(async (item: BOQItemWithLibrary) => {\n    console.log('ðŸ“‹ Duplicate requested for item:', item.id);\n    setIsLoading(true);\n\n    try {\n      const duplicateData = {\n        tender_id: item.tender_id,\n        client_position_id: item.client_position_id,\n        item_type: item.item_type,\n        description: `${item.description} (ÐºÐ¾Ð¿Ð¸Ñ)`,\n        unit: item.unit,\n        quantity: item.quantity,\n        unit_rate: item.unit_rate,\n        material_id: item.material_id,\n        work_id: item.work_id,\n        library_material_id: item.library_material_id,\n        library_work_id: item.library_work_id,\n        category: item.category,\n        subcategory: item.subcategory,\n        notes: item.notes,\n        markup_percentage: item.markup_percentage\n      };\n\n      console.log('ðŸ“¡ Calling BOQ create API for duplicate:', duplicateData);\n      const result = await boqApi.create(duplicateData);\n      console.log('ðŸ“¦ Duplicate API response:', result);\n\n      if (result.error) {\n        console.error('âŒ Duplicate failed:', result.error);\n        message.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð´ÑƒÐ±Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°');\n        return;\n      }\n\n      console.log('âœ… Duplicate successful');\n      message.success('Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚ Ð¿Ñ€Ð¾Ð´ÑƒÐ±Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½');\n      onUpdate();\n    } catch (error) {\n      console.error('ðŸ’¥ Exception during duplicate:', error);\n      message.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð´ÑƒÐ±Ð»Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð°');\n    } finally {\n      setIsLoading(false);\n    }\n  }, [onUpdate]);\n\n  // Determine whether to use virtual list or draggable list\n  const useVirtualList = filteredItems.length > 100;\n  const listHeight = Math.min(maxHeight, filteredItems.length * 180);\n\n  console.log('ðŸ“Š List rendering decision:', {\n    itemsCount: filteredItems.length,\n    useVirtualList,\n    listHeight,\n    maxHeight\n  });\n\n  return (\n    <div className=\"space-y-4\">\n      {searchable && (\n        <Input.Search\n          placeholder=\"ÐŸÐ¾Ð¸ÑÐº ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² BOQ...\"\n          value={searchTerm}\n          onChange={(e) => handleSearchChange(e.target.value)}\n          allowClear\n        />\n      )}\n\n      {useVirtualList ? (\n        <VirtualList\n          items={filteredItems}\n          height={listHeight}\n          editingItem={editingItem}\n          isLoading={isLoading}\n          editable={editable}\n          onStartEdit={handleStartEdit}\n          onSaveEdit={handleSaveEdit}\n          onCancelEdit={handleCancelEdit}\n          onDelete={handleDelete}\n          onDuplicate={handleDuplicate}\n          setEditingItem={setEditingItem}\n        />\n      ) : (\n        <DraggableList\n          items={filteredItems}\n          clientPositionId={clientPositionId}\n          onReorder={handleReorder}\n          height={listHeight}\n          editingItem={editingItem}\n          isLoading={isLoading}\n          editable={editable}\n          onStartEdit={handleStartEdit}\n          onSaveEdit={handleSaveEdit}\n          onCancelEdit={handleCancelEdit}\n          onDelete={handleDelete}\n          onDuplicate={handleDuplicate}\n          setEditingItem={setEditingItem}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default BOQItemList;