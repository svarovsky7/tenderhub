import { supabase } from '../client';
import type {
  BOQItem,
  BOQItemInsert,
  BOQItemUpdate,
  BOQFilters,
  ApiResponse,
  PaginatedResponse,
  BOQItemWithPosition,
  BOQItemWithLibrary,
  BOQSummary,
  HierarchyMoveOperation,
} from '../types';
import { handleSupabaseError, applyPagination, type PaginationOptions } from './utils';

// BOQ API (Enhanced for Hierarchical Structure)
export const boqApi = {
  /**
   * Get BOQ items for a tender with hierarchical support
   * Supports filtering by client position and enhanced sorting
   */
  async getByTenderId(
    tenderId: string,
    filters: BOQFilters = {},
    pagination: PaginationOptions = {}
  ): Promise<PaginatedResponse<BOQItemWithPosition>> {
    try {
      let query = supabase
        .from('boq_items')
        .select(`
          *,
          material:materials_library(*),
          work_item:works_library(*),
          client_position:client_positions(*)
        `, { count: 'exact' })
        .eq('tender_id', tenderId);

      // Apply hierarchical filters
      if (filters.client_position_id) {
        query = query.eq('client_position_id', filters.client_position_id);
      }

      if (filters.item_type?.length) {
        query = query.in('item_type', filters.item_type);
      }
      
      if (filters.category?.length) {
        query = query.in('category', filters.category);
      }
      
      if (filters.min_amount !== undefined) {
        query = query.gte('total_amount', filters.min_amount);
      }
      
      if (filters.max_amount !== undefined) {
        query = query.lte('total_amount', filters.max_amount);
      }
      
      if (filters.search) {
        query = query.or(`description.ilike.%${filters.search}%,item_number.ilike.%${filters.search}%,notes.ilike.%${filters.search}%`);
      }

      // Apply pagination
      const paginatedQuery = applyPagination(query, pagination);
      
      // Enhanced ordering for hierarchical display
      const { data, error, count } = await paginatedQuery
        .order('client_position_id', { nullsFirst: false })
        .order('sub_number');

      if (error) {
        return {
          error: handleSupabaseError(error, 'Get BOQ items'),
        };
      }

      const { page = 1, limit = 20 } = pagination;
      
      return {
        data: data || [],
        pagination: {
          page,
          limit,
          total: count || 0,
          pages: Math.ceil((count || 0) / limit),
        },
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Get BOQ items'),
      };
    }
  },

  /**
   * Get BOQ items by client position ID
   * Optimized for displaying items within a specific position
   */
  async getByClientPositionId(
    clientPositionId: string,
    filters: Omit<BOQFilters, 'client_position_id'> = {},
    pagination: PaginationOptions = {}
  ): Promise<PaginatedResponse<BOQItemWithLibrary>> {
    try {
      let query = supabase
        .from('boq_items')
        .select(`
          *,
          material:materials_library(*),
          work_item:works_library(*)
        `, { count: 'exact' })
        .eq('client_position_id', clientPositionId);

      // Apply filters (excluding client_position_id)
      if (filters.item_type?.length) {
        query = query.in('item_type', filters.item_type);
      }
      
      if (filters.category?.length) {
        query = query.in('category', filters.category);
      }
      
      if (filters.min_amount !== undefined) {
        query = query.gte('total_amount', filters.min_amount);
      }
      
      if (filters.max_amount !== undefined) {
        query = query.lte('total_amount', filters.max_amount);
      }
      
      if (filters.search) {
        query = query.or(`description.ilike.%${filters.search}%,item_number.ilike.%${filters.search}%,notes.ilike.%${filters.search}%`);
      }

      // Apply pagination
      const paginatedQuery = applyPagination(query, pagination);
      
      const { data, error, count } = await paginatedQuery
        .order('sub_number')
        .order('sort_order');

      if (error) {
        return {
          error: handleSupabaseError(error, 'Get BOQ items by position'),
        };
      }

      const { page = 1, limit = 20 } = pagination;
      
      return {
        data: data || [],
        pagination: {
          page,
          limit,
          total: count || 0,
          pages: Math.ceil((count || 0) / limit),
        },
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Get BOQ items by position'),
      };
    }
  },

  // Get BOQ summary for a tender
  async getSummary(tenderId: string): Promise<ApiResponse<BOQSummary>> {
    try {
      // BOQ summary calculated from boq_items
      const { data: boqItems, error } = await supabase
        .from('boq_items')
        .select('total_amount')
        .eq('tender_id', tenderId);
      
      if (error) {
        return {
          error: handleSupabaseError(error, 'Get BOQ summary'),
        };
      }

      const data = {
        tender_id: tenderId,
        total_items: boqItems?.length || 0,
        total_amount: boqItems?.reduce((sum, item) => sum + (item.total_amount || 0), 0) || 0,
        materials_count: 0, // Could be calculated if needed
        works_count: 0, // Could be calculated if needed
      };

      return {
        data,
        message: 'BOQ summary loaded successfully',
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Get BOQ summary'),
      };
    }
  },

  /**
   * Create BOQ item with automatic sub-numbering
   * If client_position_id is provided, sub_number is automatically assigned
   */
  async create(item: BOQItemInsert): Promise<ApiResponse<BOQItem>> {
    console.log('üöÄ boqApi.create called with:', item);
    
    try {
      // Get client position to determine item_number format
      if (!item.client_position_id) {
        console.error('‚ùå Missing client_position_id for BOQ item');
        return { error: 'Client position ID is required' };
      }

      console.log('üîç Fetching client position info...');
      const { data: position, error: positionError } = await supabase
        .from('client_positions')
        .select('position_number')
        .eq('id', item.client_position_id)
        .single();

      if (positionError || !position) {
        console.error('‚ùå Failed to fetch client position:', positionError);
        return { error: 'Failed to fetch client position information' };
      }

      console.log('üìã Position found:', position);

      // Get the count of existing BOQ items in this position
      console.log('üîç Counting existing BOQ items in position...');
      const { count, error: countError } = await supabase
        .from('boq_items')
        .select('*', { count: 'exact', head: true })
        .eq('client_position_id', item.client_position_id);

      if (countError) {
        console.error('‚ùå Failed to count existing BOQ items:', countError);
        return { error: 'Failed to count existing BOQ items' };
      }

      // Generate item_number in format "X.Y" where X is position number, Y is sub-number
      const subNumber = (count || 0) + 1;
      const itemNumber = `${position.position_number}.${subNumber}`;
      
      console.log(`üî¢ Generated item_number: ${itemNumber} (position: ${position.position_number}, sub: ${subNumber})`);

      // Create the item with generated item_number and sub_number
      const itemToInsert = {
        ...item,
        item_number: itemNumber,
        sub_number: subNumber,
        sort_order: item.sort_order || (count || 0)
      };

      console.log('üíæ Inserting BOQ item:', itemToInsert);
      const { data, error } = await supabase
        .from('boq_items')
        .insert(itemToInsert)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Failed to insert BOQ item:', error);
        return {
          error: handleSupabaseError(error, 'Create BOQ item'),
        };
      }

      console.log('‚úÖ BOQ item created successfully:', data.id);
      return {
        data,
        message: 'BOQ item created successfully',
      };
    } catch (error) {
      console.error('üí• Exception in create BOQ item:', error);
      return {
        error: handleSupabaseError(error, 'Create BOQ item'),
      };
    }
  },

  // Bulk create BOQ items (for Excel imports)
  async bulkCreate(tenderId: string, items: BOQItemInsert[]): Promise<ApiResponse<number>> {
    try {
      // Use the database function for optimized bulk insert
      const { data, error } = await supabase.rpc('bulk_insert_boq_items', {
        p_tender_id: tenderId,
        p_items: items,
      });

      if (error) {
        return {
          error: handleSupabaseError(error, 'Bulk create BOQ items'),
        };
      }

      return {
        data,
        message: `${data} BOQ items created successfully`,
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Bulk create BOQ items'),
      };
    }
  },

  /**
   * Bulk create BOQ items for a specific client position
   * Uses optimized database function with automatic sub-numbering
   */
  async bulkCreateInPosition(
    clientPositionId: string, 
    items: BOQItemInsert[]
  ): Promise<ApiResponse<number>> {
    try {
      const { data, error } = await supabase.rpc('bulk_insert_boq_items_to_position', {
        p_client_position_id: clientPositionId,
        p_items: items,
      });

      if (error) {
        return {
          error: handleSupabaseError(error, 'Bulk create BOQ items in position'),
        };
      }

      return {
        data,
        message: `${data} BOQ items created in position successfully`,
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Bulk create BOQ items in position'),
      };
    }
  },

  /**
   * Move BOQ item to different client position
   * Automatically handles sub-number reassignment
   */
  async moveToPosition(
    itemId: string,
    targetPositionId: string,
    newSortOrder?: number
  ): Promise<ApiResponse<BOQItem>> {
    try {
      // Get next sub number for target position
      const { data: nextSubNumber, error: subError } = await supabase.rpc('get_next_sub_number', {
        p_client_position_id: targetPositionId,
      });

      if (subError) {
        return {
          error: handleSupabaseError(subError, 'Get next sub number'),
        };
      }

      // Update the item
      const updates: BOQItemUpdate = {
        client_position_id: targetPositionId,
        sub_number: nextSubNumber,
        sort_order: newSortOrder || 0,
      };

      const { data, error } = await supabase
        .from('boq_items')
        .update(updates)
        .eq('id', itemId)
        .select()
        .single();

      if (error) {
        return {
          error: handleSupabaseError(error, 'Move BOQ item to position'),
        };
      }

      return {
        data,
        message: 'BOQ item moved successfully',
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Move BOQ item to position'),
      };
    }
  },

  /**
   * Batch move multiple BOQ items between positions
   * Optimized for drag-and-drop operations
   */
  async batchMove(operations: HierarchyMoveOperation[]): Promise<ApiResponse<number>> {
    try {
      let successCount = 0;
      const errors: string[] = [];

      for (const operation of operations) {
        const result = await this.moveToPosition(
          operation.itemId,
          operation.targetPositionId,
          operation.newSortOrder
        );

        if (result.error) {
          errors.push(`Item ${operation.itemId}: ${result.error}`);
        } else {
          successCount++;
        }
      }

      if (errors.length > 0) {
        return {
          error: `Some moves failed: ${errors.join('; ')}`,
        };
      }

      return {
        data: successCount,
        message: `${successCount} items moved successfully`,
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Batch move BOQ items'),
      };
    }
  },

  /**
   * Reorder BOQ items within a client position
   * Updates sort_order for proper sequencing
   */
  async reorderInPosition(
    clientPositionId: string,
    itemIds: string[]
  ): Promise<ApiResponse<number>> {
    try {
      const updates = itemIds.map((itemId, index) => 
        supabase
          .from('boq_items')
          .update({ sort_order: index })
          .eq('id', itemId)
          .eq('client_position_id', clientPositionId)
      );

      const results = await Promise.all(updates);
      const errors = results.filter(result => result.error);

      if (errors.length > 0) {
        return {
          error: `Failed to reorder items: ${errors[0].error?.message}`,
        };
      }

      return {
        data: itemIds.length,
        message: `${itemIds.length} items reordered successfully`,
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Reorder BOQ items in position'),
      };
    }
  },

  // Update BOQ item
  async update(id: string, updates: BOQItemUpdate): Promise<ApiResponse<BOQItem>> {
    try {
      const { data, error } = await supabase
        .from('boq_items')
        .update(updates)
        .eq('id', id)
        .select()
        .single();

      if (error) {
        return {
          error: handleSupabaseError(error, 'Update BOQ item'),
        };
      }

      return {
        data,
        message: 'BOQ item updated successfully',
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Update BOQ item'),
      };
    }
  },

  // Delete BOQ item
  async delete(id: string): Promise<ApiResponse<null>> {
    try {
      const { error } = await supabase
        .from('boq_items')
        .delete()
        .eq('id', id);

      if (error) {
        return {
          error: handleSupabaseError(error, 'Delete BOQ item'),
        };
      }

      return {
        data: null,
        message: 'BOQ item deleted successfully',
      };
    } catch (error) {
      return {
        error: handleSupabaseError(error, 'Delete BOQ item'),
      };
    }
  },
};

// BOQ Items API (Additional methods for compatibility)
export const boqItemsApi = {
  async getByPosition(positionId: string): Promise<ApiResponse<BOQItem[]>> {
    try {
      const { data, error } = await supabase
        .from('boq_items')
        .select('*')
        .eq('client_position_id', positionId)
        .order('item_number');

      if (error) {
        return {
          error: handleSupabaseError(error, 'Get BOQ items by position'),
        };
      }

      return {
        data: data || [],
        message: 'BOQ items loaded successfully',
      };
    } catch (error) {
      return {
        error: `Failed to get BOQ items: ${error}`,
      };
    }
  },

  async getByTender(tenderId: string): Promise<ApiResponse<BOQItem[]>> {
    try {
      const { data, error } = await supabase
        .from('boq_items')
        .select('*')
        .eq('tender_id', tenderId)
        .order('item_number');

      if (error) {
        return {
          error: handleSupabaseError(error, 'Get BOQ items by tender'),
        };
      }

      return {
        data: data || [],
        message: 'BOQ items loaded successfully',
      };
    } catch (error) {
      return {
        error: `Failed to get BOQ items: ${error}`,
      };
    }
  },

  async getById(itemId: string): Promise<ApiResponse<BOQItem>> {
    try {
      const { data, error } = await supabase
        .from('boq_items')
        .select('*')
        .eq('id', itemId)
        .single();

      if (error) {
        return {
          error: handleSupabaseError(error, 'Get BOQ item'),
        };
      }

      return {
        data,
        message: 'BOQ item loaded successfully',
      };
    } catch (error) {
      return {
        error: `Failed to get BOQ item: ${error}`,
      };
    }
  },

  async create(itemData: BOQItemInsert): Promise<ApiResponse<BOQItem>> {
    console.log('üöÄ boqItemsApi.create called with:', itemData);
    
    try {
      // Get client position to determine item_number format
      if (!itemData.client_position_id) {
        console.error('‚ùå Missing client_position_id for BOQ item');
        return { error: 'Client position ID is required' };
      }

      console.log('üîç Fetching client position info...');
      const { data: position, error: positionError } = await supabase
        .from('client_positions')
        .select('position_number')
        .eq('id', itemData.client_position_id)
        .single();

      if (positionError || !position) {
        console.error('‚ùå Failed to fetch client position:', positionError);
        return { error: 'Failed to fetch client position information' };
      }

      console.log('üìã Position found:', position);

      // Get the count of existing BOQ items in this position
      console.log('üîç Counting existing BOQ items in position...');
      const { count, error: countError } = await supabase
        .from('boq_items')
        .select('*', { count: 'exact', head: true })
        .eq('client_position_id', itemData.client_position_id);

      if (countError) {
        console.error('‚ùå Failed to count existing BOQ items:', countError);
        return { error: 'Failed to count existing BOQ items' };
      }

      // Generate item_number in format "X.Y" where X is position number, Y is sub-number
      const subNumber = (count || 0) + 1;
      const itemNumber = `${position.position_number}.${subNumber}`;
      
      console.log(`üî¢ Generated item_number: ${itemNumber} (position: ${position.position_number}, sub: ${subNumber})`);

      // Create the item with generated item_number and sub_number
      const itemToInsert = {
        ...itemData,
        item_number: itemNumber,
        sub_number: subNumber,
        sort_order: itemData.sort_order || (count || 0)
      };

      console.log('üíæ Inserting BOQ item:', itemToInsert);
      const { data, error } = await supabase
        .from('boq_items')
        .insert(itemToInsert)
        .select()
        .single();

      if (error) {
        console.error('‚ùå Failed to insert BOQ item:', error);
        return {
          error: handleSupabaseError(error, 'Create BOQ item'),
        };
      }

      console.log('‚úÖ BOQ item created successfully:', data.id);
      return {
        data,
        message: 'BOQ item created successfully',
      };
    } catch (error) {
      console.error('üí• Exception in create BOQ item:', error);
      return {
        error: `Failed to create BOQ item: ${error}`,
      };
    }
  },

  async update(itemId: string, updates: BOQItemUpdate): Promise<ApiResponse<BOQItem>> {
    try {
      const { data, error } = await supabase
        .from('boq_items')
        .update(updates)
        .eq('id', itemId)
        .select()
        .single();

      if (error) {
        return {
          error: handleSupabaseError(error, 'Update BOQ item'),
        };
      }

      return {
        data,
        message: 'BOQ item updated successfully',
      };
    } catch (error) {
      return {
        error: `Failed to update BOQ item: ${error}`,
      };
    }
  },

  async delete(itemId: string): Promise<ApiResponse<boolean>> {
    try {
      const { error } = await supabase
        .from('boq_items')
        .delete()
        .eq('id', itemId);

      if (error) {
        return {
          error: handleSupabaseError(error, 'Delete BOQ item'),
        };
      }

      return {
        data: true,
        message: 'BOQ item deleted successfully',
      };
    } catch (error) {
      return {
        error: `Failed to delete BOQ item: ${error}`,
      };
    }
  },
};