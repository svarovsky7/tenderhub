import { supabase } from '../client';
import * as XLSX from 'xlsx-js-style';
import type { ApiResponse, ClientPositionType } from '../types';
import { handleSupabaseError } from './utils';
import { HIERARCHY_LEVELS } from '../../../utils/clientPositionHierarchy';
import { tenderVersioningApi, type TenderVersionMapping } from './tender-versioning';

export interface VersionUploadOptions {
  parentTenderId?: string;  // ID —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–π –≤–µ—Ä—Å–∏–∏ —Ç–µ–Ω–¥–µ—Ä–∞
  autoMatch?: boolean;      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π
  matchingThreshold?: number; // –ü–æ—Ä–æ–≥ –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è
}

export interface VersionUploadResult {
  tenderId: string;
  positionsCount: number;
  mappings?: TenderVersionMapping[];
  matchedCount?: number;
  newCount?: number;
  deletedCount?: number;
}

export const clientWorksVersioningApi = {
  /**
   * –ó–∞–≥—Ä—É–∑–∫–∞ Excel —Ñ–∞–π–ª–∞ –∫–∞–∫ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏ —Ç–µ–Ω–¥–µ—Ä–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ–º
   */
  async uploadAsNewVersion(
    file: File,
    options: VersionUploadOptions,
    onProgress?: (progress: number, step: string) => void
  ): Promise<ApiResponse<VersionUploadResult>> {
    console.log('üöÄ uploadAsNewVersion called with:', {
      fileName: file.name,
      parentTenderId: options.parentTenderId,
      autoMatch: options.autoMatch
    });

    try {
      // –®–∞–≥ 1: –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é —Ç–µ–Ω–¥–µ—Ä–∞
      onProgress?.(5, '–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏ —Ç–µ–Ω–¥–µ—Ä–∞...');

      if (!options.parentTenderId) {
        return { error: '–ù–µ —É–∫–∞–∑–∞–Ω —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π —Ç–µ–Ω–¥–µ—Ä –¥–ª—è –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è' };
      }

      const { data: newTenderId, error: versionError } = await tenderVersioningApi.createNewVersion(
        options.parentTenderId
      );

      if (versionError || !newTenderId) {
        console.error('‚ùå Failed to create new version:', versionError);
        return { error: versionError || '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –≤–µ—Ä—Å–∏—é' };
      }

      console.log('‚úÖ Created new tender version:', newTenderId);

      // –®–∞–≥ 2: –ß–∏—Ç–∞–µ–º –∏ –ø–∞—Ä—Å–∏–º Excel —Ñ–∞–π–ª
      onProgress?.(10, '–ß—Ç–µ–Ω–∏–µ Excel —Ñ–∞–π–ª–∞...');
      const data = await file.arrayBuffer();
      const workbook = XLSX.read(data, { type: 'array' });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];

      // –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –∏–∑ Excel
      const rows = XLSX.utils.sheet_to_json<Record<string, unknown>>(sheet, {
        header: ['position_number', 'position_type', 'work_name', 'unit', 'volume', 'client_note'],
        range: 1,
        raw: false,
        defval: ''
      });

      console.log('üìä Parsed rows from Excel:', rows.length);
      onProgress?.(20, '–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ Excel...');

      // –ú–∞–ø–ø–∏–Ω–≥ —Ç–∏–ø–æ–≤ –ø–æ–∑–∏—Ü–∏–π
      const russianTypeMapping: Record<string, ClientPositionType> = {
        '—Å—Ç–∞—Ç—å—è': 'article',
        '—Ä–∞–∑–¥–µ–ª': 'section',
        '–ø–æ–¥—Ä–∞–∑–¥–µ–ª': 'subsection',
        '–∑–∞–≥–æ–ª–æ–≤–æ–∫': 'header',
        '–ø–æ–¥–∑–∞–≥–æ–ª–æ–≤–æ–∫': 'subheader',
        '–∏—Å–ø–æ–ª–Ω—è–µ–º–∞—è': 'executable'
      };

      const normalizePositionType = (rawType: string): ClientPositionType => {
        if (!rawType) return 'executable';
        const cleanType = String(rawType).trim().toLowerCase();
        const validTypes = ['article', 'section', 'subsection', 'header', 'subheader', 'executable'];

        if (validTypes.includes(cleanType)) {
          return cleanType as ClientPositionType;
        }

        return russianTypeMapping[cleanType] || 'executable';
      };

      // –§–∏–ª—å—Ç—Ä—É–µ–º –∏ –≥—Ä—É–ø–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
      const positionsMap = new Map<string, any>();

      rows.forEach((row: any) => {
        const positionNum = String(row.position_number).trim();
        const workName = String(row.work_name).trim();

        if (!positionNum || !workName) return;

        const positionType = normalizePositionType(row.position_type);

        // –î–ª—è –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –≤–∞–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –Ω–æ–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
        positionsMap.set(positionNum, {
          original_number: positionNum,
          work_name: workName,
          unit: row.unit ? String(row.unit).trim() : '',
          volume: row.volume ? Number(row.volume) : 0,
          client_note: row.client_note ? String(row.client_note).trim() : null,
          position_type: positionType,
          hierarchy_level: HIERARCHY_LEVELS[positionType]
        });
      });

      console.log('üì¶ Grouped into positions:', positionsMap.size);

      if (positionsMap.size === 0) {
        // –£–¥–∞–ª—è–µ–º –ø—É—Å—Ç—É—é –≤–µ—Ä—Å–∏—é
        await supabase.from('tenders').delete().eq('id', newTenderId);
        return { error: '–í Excel —Ñ–∞–π–ª–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤–∞–ª–∏–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö' };
      }

      // –®–∞–≥ 3: –°–æ–∑–¥–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –≤ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏
      onProgress?.(30, '–°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π –≤ –Ω–æ–≤–æ–π –≤–µ—Ä—Å–∏–∏...');

      let positionNumber = 1;
      const createdPositions: any[] = [];

      for (const [key, positionData] of positionsMap) {
        const { data: position, error: posError } = await supabase
          .from('client_positions')
          .insert({
            tender_id: newTenderId,
            position_number: positionNumber++,
            item_no: positionData.original_number.substring(0, 10),
            work_name: positionData.work_name,
            unit: positionData.unit,
            volume: positionData.volume,
            client_note: positionData.client_note,
            position_type: positionData.position_type,
            hierarchy_level: positionData.hierarchy_level,
            total_materials_cost: 0,
            total_works_cost: 0
          })
          .select()
          .single();

        if (posError) {
          console.error('‚ùå Failed to create position:', posError);
          continue;
        }

        createdPositions.push(position);
      }

      console.log(`‚úÖ Created ${createdPositions.length} positions in new version`);

      // –®–∞–≥ 4: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
      let mappings: TenderVersionMapping[] = [];
      let matchedCount = 0;
      let newCount = 0;
      let deletedCount = 0;

      if (options.autoMatch) {
        onProgress?.(50, '–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–π –º–µ–∂–¥—É –≤–µ—Ä—Å–∏—è–º–∏...');

        const { data: matchResults, error: matchError } = await tenderVersioningApi.autoMatchPositions(
          options.parentTenderId,
          newTenderId,
          {
            fuzzyThreshold: options.matchingThreshold || 0.7,
            autoConfirmThreshold: 0.95
          }
        );

        if (matchError) {
          console.error('‚ùå Failed to auto-match positions:', matchError);
        } else if (matchResults) {
          mappings = matchResults;

          // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
          matchedCount = mappings.filter(m => m.mapping_type === 'exact' || m.mapping_type === 'fuzzy').length;
          newCount = mappings.filter(m => m.mapping_type === 'new').length;
          deletedCount = mappings.filter(m => m.mapping_type === 'deleted').length;

          console.log(`üìä Matching statistics:
            - Matched: ${matchedCount}
            - New: ${newCount}
            - Deleted: ${deletedCount}`);

          // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞–ø–ø–∏–Ω–≥–∏ –≤ –±–∞–∑—É –∏ –ø–æ–ª—É—á–∞–µ–º –∏—Ö —Å ID
          onProgress?.(70, '–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–π...');
          const saveResult = await tenderVersioningApi.saveMappings(mappings);

          if (saveResult.error) {
            console.error('‚ö†Ô∏è Failed to save mappings:', saveResult.error);
          } else if (saveResult.data) {
            // –û–±–Ω–æ–≤–ª—è–µ–º –º–∞–ø–ø–∏–Ω–≥–∏ —Å –ø–æ–ª—É—á–µ–Ω–Ω—ã–º–∏ ID –∏–∑ –ë–î
            mappings = mappings.map((m, index) => ({
              ...m,
              id: saveResult.data?.[index]?.id || m.id
            }));
            console.log('‚úÖ Mappings saved with IDs');
          }
        }

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ–Ω—è–µ–º –º–∞–ø–ø–∏–Ω–≥–∏ –∏ –ø–µ—Ä–µ–Ω–æ—Å–∏–º –¥–∞–Ω–Ω—ã–µ
        if (mappings.length > 0) {
          onProgress?.(80, '–ü–µ—Ä–µ–Ω–æ—Å BOQ items, –î–û–ü –ø–æ–∑–∏—Ü–∏–π –∏ —Å–≤—è–∑–µ–π...');
          console.log('üîÑ Automatically applying mappings and transferring data...');

          const transferResult = await tenderVersioningApi.applyMappings(newTenderId);

          if (transferResult.error) {
            console.error('‚ö†Ô∏è Data transfer failed:', transferResult.error);
            // –ù–µ —Å—á–∏—Ç–∞–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–æ–π, –ø–æ–∑–≤–æ–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –ø–æ–∑–∂–µ
            console.log('‚ÑπÔ∏è User can manually transfer data later if needed');
          } else {
            console.log('‚úÖ Data transfer completed successfully');
            onProgress?.(95, '–ü–µ—Ä–µ–Ω–æ—Å –¥–∞–Ω–Ω—ã—Ö –∑–∞–≤–µ—Ä—à–µ–Ω');
          }
        }
      }

      onProgress?.(100, '–ó–∞–≤–µ—Ä—à–µ–Ω–æ!');

      return {
        data: {
          tenderId: newTenderId,
          positionsCount: createdPositions.length,
          mappings: options.autoMatch ? mappings : undefined,  // –¢–µ–ø–µ—Ä—å –º–∞–ø–ø–∏–Ω–≥–∏ –±—É–¥—É—Ç —Å ID
          matchedCount,
          newCount,
          deletedCount
        },
        message: `–°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —Ç–µ–Ω–¥–µ—Ä–∞ —Å ${createdPositions.length} –ø–æ–∑–∏—Ü–∏—è–º–∏`
      };
    } catch (error) {
      console.error('üí• Exception in uploadAsNewVersion:', error);
      return {
        error: error instanceof Error ? error.message : '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ'
      };
    }
  },

  /**
   * –ó–∞–≥—Ä—É–∑–∫–∞ Excel —Ñ–∞–π–ª–∞ –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ç–µ–Ω–¥–µ—Ä (–æ–±—ã—á–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –±–µ–∑ –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è)
   */
  async uploadToExistingTender(
    tenderId: string,
    file: File,
    onProgress?: (progress: number, step: string) => void
  ): Promise<ApiResponse<{ positionsCount: number }>> {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ clientWorksApi
    const { clientWorksApi } = await import('./client-works');
    return clientWorksApi.uploadFromXlsx(tenderId, file, onProgress);
  },

  /**
   * –ü—Ä–æ–≤–µ—Ä–∫–∞, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–Ω–¥–µ—Ä –≤–µ—Ä—Å–∏–µ–π –¥—Ä—É–≥–æ–≥–æ —Ç–µ–Ω–¥–µ—Ä–∞
   */
  async checkIfVersion(tenderId: string): Promise<ApiResponse<{
    isVersion: boolean;
    parentTenderId?: string;
    version?: number;
  }>> {
    console.log('üöÄ Checking if tender is a version:', tenderId);

    try {
      const { data, error } = await supabase
        .from('tenders')
        .select('parent_version_id, version')
        .eq('id', tenderId)
        .single();

      if (error) {
        console.error('‚ùå Failed to check tender version:', error);
        return { error: error.message };
      }

      const isVersion = !!data?.parent_version_id;

      console.log(`‚úÖ Tender ${isVersion ? 'is' : 'is not'} a version`);

      return {
        data: {
          isVersion,
          parentTenderId: data?.parent_version_id,
          version: data?.version
        }
      };
    } catch (error) {
      console.error('üí• Exception in checkIfVersion:', error);
      return { error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }
};